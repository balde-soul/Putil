# coding=utf-8
import tensorflow as tf


class Model:
    def __init__(self, **options):
        """
        init the model, do some member variance declaration
        :param options:
        """
        # todo: save the total dict param
        # todo: maybe {"arch_com": {}, "opt":{}, "arch_def":{}, "training":{}}
        self._param = None
        # todo: save the param which shared while using self._param_arch_def to build arch, this is to avoid to much
        # todo: param write and change in the config file, but you should complement the arch_def using this arch_com
        # todo: maybe {"base_model": "name", "regularizer_weight": float, "loss_type": "name", "param_dtype": float,
        # todo: "moving_decay": float, ...}
        self._param_arch_com = None
        # todo: save the param which is used for opt-init, maybe: { "opt": "name", "opt_param":{ ...}}
        self._param_opt = None
        # todo: save the param which is used for building the arch, with arch_com
        # todo: maybe {"name from base model": { ...some param for build}}
        self._param_arch_def = None
        # todo: save the param which is used in training time
        # todo: maybe {"summary_path": "path", "val_epoch": int, "display_batch": int,
        # todo:              "epoch": int, "batch_size": int, ...}
        self._param_training = None

        # :
        self._placeholder = dict()

        # todo: collect the name which represent model train outputs dict keys
        self._train_result_reflect = []
        # todo: collect the name which represent model val outputs dict keys
        self._val_result_reflect = []

        self._sess = tf.Session()
        self._loss = None
        self._train_op = None
        self._opt = None
        self._step = None
        pass

    # todo: make the placeholder needed in model run
    def __make_placeholder(self, data):
        return {}
        pass

    # todo: process the param input to special param in the self, for easier use
    def extract_param(self, param):
        pass

    # todo: build the model, complement self._loss with loss for training
    def __build_with_loss(self):
        pass

    # todo: complement the self._opt for training
    def __build_opt(self):
        pass

    # todo: init the model which will call in every cv estimate
    def re_init(self):
        # : reset the graph to default
        tf.reset_default_graph()
        # :
        self.__build_with_loss()
        # : complement the self._sess
        self._sess = tf.Session()
        # : make self._step
        self._step = tf.Variable(0, trainable=True)
        # : complement the opter
        self.__build_opt()
        # : make exponential_moving_average
        _ema = tf.train.ExponentialMovingAverage(self._param_arch_com['moving_average'], num_updates=self._step)
        # : dependent on the _ema.apply build self._train_op
        with tf.control_dependencies([_ema.apply(tf.trainable_variables())]):
            self._train_op = self._opt.minimize(self._loss. self._step)
        pass

    # todo: input data which generated by the DataGenerator and train on these data as one batch
    # todo: return the result you want to estimate packed into dictionary
    def TrainCV(self, data):
        # todo: feed the placeholder
        feed = self.__make_placeholder(data)
        # todo: run the loss and train and ***
        self._sess.run([], feed_dict=feed)
        # todo: return the result want to estimate: TrainResultReflect
        return {}
        pass

    # todo: input data which generated by DataGenerator and Val on these data as one batch
    # todo: return the result you want to estimate packed into dictionary
    def Val(self, data):
        feed = self.__make_placeholder(data)
        self._sess.run([], feed_dict=feed)
        return {}

    # : return the reflect dict represent the result name which create int the train
    @property
    def TrainResultReflect(self):
        return self._train_result_reflect

    # : return the reflect dict represent the result name which create int the val
    @property
    def ValResultReflect(self):
        return self._val_result_reflect
    pass
